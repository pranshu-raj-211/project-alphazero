import time
import logging
import random
import chess
import chess.engine
import chess.pgn



logging.basicConfig(level=logging.INFO, )

def evaluate_board(board):
    white_pieces_value = sum(
        piece_value(piece)
        for piece in board.piece_map().values()
        if piece.color == chess.WHITE
    )
    black_pieces_value = sum(
        piece_value(piece)
        for piece in board.piece_map().values()
        if piece.color == chess.BLACK
    )
    material_advantage = white_pieces_value - black_pieces_value
    return material_advantage


# Assign values to each piece
def piece_value(piece):
    if piece.piece_type == chess.PAWN:
        return 1
    elif piece.piece_type == chess.KNIGHT:
        return 3.2
    elif piece.piece_type == chess.BISHOP:
        return 3.4
    elif piece.piece_type == chess.ROOK:
        return 5
    elif piece.piece_type == chess.QUEEN:
        return 9
    elif piece.piece_type == chess.KING:
        return 100
    else:
        return 0


# * I'm counting only those nodes for which I'm performing a search, not for leaf nodes
def minimax(
    board: chess.Board,
    depth: int,
    alpha: float,
    beta: float,
    maximizing_player: bool,
    node_count: int,
):
    node_count += 1
    if depth == 0 or board.is_game_over():
        return evaluate_board(board), node_count    

    if maximizing_player:
        # engine as white
        max_eval = float("-inf")
        for move in board.legal_moves:
            board.push(move)
            evaluation, node_count = minimax(
                board, depth - 1, alpha, beta, False, node_count
            )
            board.pop()
            max_eval = max(max_eval, evaluation)
            alpha = max(alpha, evaluation)
            # prune
            # if beta <= alpha:
            #     break
        return max_eval, node_count
    else:
        # engine as black
        min_eval = float("inf")
        for move in board.legal_moves:
            board.push(move)
            evaluation, node_count = minimax(
                board, depth - 1, alpha, beta, True, node_count
            )
            board.pop()
            min_eval = min(min_eval, evaluation)
            beta = min(beta, evaluation)
            # prune
            # if beta <= alpha:
            #     break
        return min_eval, node_count


def choose_move(board:chess.Board, depth:int):
    best_move = None
    max_eval = float("-inf")
    alpha = float("-inf")
    beta = float("inf")
    total_nodes = 0

    for move in board.legal_moves:
        board.push(move)
        evaluation, node_count = minimax(board, depth - 1, alpha, beta, False, 0)
        board.pop()

        total_nodes+=node_count
        if evaluation > max_eval:
            max_eval = evaluation
            best_move = move

    return best_move, total_nodes

def get_random_move(board:chess.Board):
    legal_moves = list(board.legal_moves)
    if not legal_moves:
        return None
    return random.choice(legal_moves)

def play(white_engine, black_engine, time_control):
    board = chess.Board()
    game = chess.pgn.Game()
    game_moves = ''
    while not board.is_game_over():
        searched_nodes = 0
        # ! logic works for white so far, need to generalize for black
        if board.turn == chess.WHITE:
            move, total_nodes = white_engine(board, 5)
            # todo : log this instead of printing
            # print(total_nodes)
            searched_nodes += total_nodes
            logging.info('nodes : ' + str(searched_nodes))
        else:
            move = black_engine(board,3)
            
        if move in board.legal_moves:
            board.push(move)
            game.add_variation(move)
            game_moves += str(move) + ' '
            logging.info(str(move))
        else:
            print(board)
            raise ValueError(f"Illegal move {move} generated by {board.turn} engine")
        

    game.headers["Result"] = board.result()
    # game.headers['Total nodes searched: '] = searched_nodes
    print("Game over")
    print("Result: ", board.result())
    print(board.variation_san)
    # print(game_moves)

    return board.result(), game_moves.strip()


def test_against_previous(current, previous, savefile: str, n_games: int):
    f = open(savefile, "a")
    print('Starting ...')
    
    for game in range(n_games):
        start_time = time.time()
        result, pgn = play(current, previous, None)
        print(pgn)
        f.write(result + pgn +'\n\n')
        end_time = time.time()
        print(f"done with game {game+1} in {end_time - start_time} seconds, result = {result}")


def perft(board, depth):
    if depth == 0:
        return 1

    nodes = 0
    for move in board.legal_moves:
        board.push(move)
        nodes += perft(board, depth - 1)
        board.pop()

    return nodes


def perft_test(board, depth):
    total_nodes = 0
    for d in range(1, depth + 1):
        nodes = perft(board.copy(), d)
        print(f"Depth {d}: {nodes} nodes")
        total_nodes += nodes

    print(f"Total nodes: {total_nodes}")


def iterative_deepening_minimax(board:chess.Board, max_depth:int, time_limit:int):
    start_time = time.time()
    best_move = None
    for depth in range(1, max_depth + 1):
        alpha = float("-inf")
        beta = float("inf")
        for move in board.legal_moves:
            board.push(move)
            evaluation = minimax(board, depth, alpha, beta, False)
            board.pop()
            if evaluation > alpha:
                alpha = evaluation
                best_move = move

        if time.time() - start_time >= time_limit:
            break
    return best_move


if __name__ == "__main__":
    test_against_previous(choose_move, get_random_move, 'v1_3plies_vs_random.txt', 1)

